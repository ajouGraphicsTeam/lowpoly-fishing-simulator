<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <title>JH</title>

    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec4 aVertexPosition;
      attribute vec3 aVertexNormal; 
      varying vec4 fColor;
      attribute vec2 vTexCoord; // 버텍스 셰이더에서 쓸 텍스쳐 좌표
      varying vec2 fTexCoord; // 프래그먼트 셰이더에 전달할 텍스쳐 좌표

      uniform mat4 uModelMat;
      uniform mat4 uViewMat;
      uniform mat4 uProjectionMat;

      uniform vec4 ambientProduct, diffuseProduct, specularProduct;
      uniform vec4 lightPosition;
      uniform float shininess;

      void main() {
        vec3 pos = (uViewMat * uModelMat * aVertexPosition).xyz;

        // vec3 light = lightPosition.xyz;
        // 이거 아래처럼 해야지 제대로 적용됨
        vec3 light = (uViewMat * lightPosition).xyz;
        
        //vec3 L = normalize( light - pos );
        // // 지금은 거리 감쇠 없이 방향 영향만 받음

        // 아래처럼 거리 감쇠를 추가하려 했는데, 거리 감쇠 factor trade off때문에 별로였음...
        // 오히려 가운데에 있는 낚시대쪽이 너무 어두워짐.
      
        // 거리 감쇠 계산 추가
        vec3 lightVector = light - pos;
        float distance = length(lightVector);
        vec3 L = normalize(lightVector);
        
        // 거리 감쇠 팩터 (거리의 제곱에 반비례)
        float attenuation = 1.0 / (1.0 + 0.001 * distance + 0.0001 * distance * distance);
        
        vec3 E = normalize( -pos );
        vec3 H = normalize( L + E ); // halfway vector for Blinn-Phong shading
        vec4 NN = vec4(aVertexNormal, 0);

        // Transform vertex normal into eye coordinates
        vec3 N = normalize( (uViewMat * uModelMat * NN).xyz );

        // Compute terms in the illumination equation
        vec4 ambient = ambientProduct;
        float d_val = max( dot(L, N), 0.0 );
        // vec4 diffuse = d_val * diffuseProduct;
        vec4 diffuse = d_val * diffuseProduct * attenuation;

        float s_val = pow( max(dot(N, H), 0.0), shininess );
        // vec4 specular = s_val * specularProduct;
        vec4 specular = s_val * specularProduct * attenuation;


        // in case the light source is behind the surface
        if( dot(L, N) < 0.0 ) {
          specular = vec4(0.0, 0.0, 0.0, 1.0);
        }

        fColor = ambient + diffuse + specular;
        fColor.a = 1.0;
        fTexCoord = vTexCoord;

        gl_PointSize = 5.0;
        gl_Position = uProjectionMat * uViewMat * uModelMat * aVertexPosition;
      }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float; // 해당 코드를 넣지 않으면 오류가 남.
      // ref. https://github.com/skeeto/webgl-game-of-life/issues/1
      varying lowp vec4 fColor;
      varying vec2 fTexCoord;
      uniform sampler2D texture;
      uniform bool useTexture; // 텍스처 사용 여부를 결정하는 플래그

      void main() {
        if (useTexture) {
          vec4 texColor = texture2D(texture, fTexCoord);
          gl_FragColor = fColor * texColor;
        } else {
          gl_FragColor = fColor; // 텍스처 없이 순수한 색상만 사용
        }
      }
    </script>

    <script type="text/javascript" src="Common/webgl-utils.js"></script>
    <script type="text/javascript" src="Common/initShaders.js"></script>
    <script type="text/javascript" src="Common/MV.js"></script>

    <script type="text/javascript" src="src/constants/drawtypes.js"></script>
    <script type="text/javascript" src="src/constants/colors.js"></script>
    <script type="text/javascript" src="src/prototypes.js"></script>
    <script type="text/javascript" src="src/components/animator.js"></script>
    <script type="text/javascript" src="src/components/transform.js"></script>
    <script type="text/javascript" src="src/components/primitives.js"></script>
    <script type="text/javascript" src="src/components/textureMaker.js"></script>
    <script type="text/javascript" src="src/constants/textures.js"></script>
    <script
      type="text/javascript"
      src="src/objects/hierarchyObject.js"></script>
    <script type="text/javascript" src="src/objects/prefabObject.js"></script>
    <script type="text/javascript" src="src/managers/rootManager.js"></script>
    <script
      type="text/javascript"
      src="src/managers/animationManager.js"></script>
    <script type="text/javascript" src="src/managers/canvasManager.js"></script>
    <script type="text/javascript" src="src/managers/cameraManager.js"></script>

    <script type="text/javascript" src="fishing.js"></script>

    <!-- DATAS -->
    <script
      type="text/javascript"
      src="src/data/animators/robotArm.js"></script>
    <script type="text/javascript" src="src/data/prefabs/robotArm.js"></script>
    <script type="text/javascript" src="src/data/prefabs/primitiveTestScene.js"></script>
    <script type="text/javascript" src="src/data/prefabs/fishingGround.js"></script>
    <script type="text/javascript" src="src/data/prefabs/ocean.js"></script>
    <script type="text/javascript" src="src/data/prefabs/skyBox.js"></script>
    <script type="text/javascript" src="src/data/prefabs/sun.js"></script>
  </head>

  <body>
    <div id="body" class="flex gap-2">
      <canvas id="gl-canvas" width="1024" height="1024">
        Oops ... your browser doesn't support the HTML5 canvas element
      </canvas>

      <div>
        <div id="panel" class="flex flex-col gap-2">
          <div class="light">
            <p>light position:</p>

            <div class="ml-7">
              <div class="my-1">
                <label>X: </label>
                <input
                  id="light_x"
                  type="number"
                  value="100"
                  step="0.01"
                  class="border pl-1" />
              </div>
              <div class="my-1">
                <label>Y: </label>
                <input
                  id="light_y"
                  type="number"
                  value="100"
                  step="0.01"
                  class="border pl-1" />
              </div>
              <div class="my-1">
                <label>Z: </label>
                <input
                  id="light_z"
                  type="number"
                  value="100"
                  step="0.01"
                  class="border pl-1" />
              </div>
            </div>

            <div class="camera">
              <p>camera:</p>

              <div class="flex gap-4">
                <label class="ml-4">- preset</label>
                <div>
                  <button id="frontCamera" type="button" class="border px-1">
                    front
                  </button>
                  <button id="sideCamera" type="button" class="border px-1">
                    side
                  </button>
                  <button id="topCamera" type="button" class="border px-1">
                    top
                  </button>
                </div>
              </div>

              <label class="ml-4">- eye</label>
              <div class="ml-7">
                <div class="my-1">
                  <label>X: </label>
                  <input
                    id="eye_x"
                    type="number"
                    value="-1.7"
                    step="0.01"
                    class="border pl-1" />
                </div>
                <div class="my-1">
                  <label>Y: </label>
                  <input
                    id="eye_y"
                    type="number"
                    value="4.3"
                    step="0.01"
                    class="border pl-1" />
                </div>
                <div class="my-1">
                  <label>Z: </label>
                  <input
                    id="eye_z"
                    type="number"
                    value="2.9"
                    step="0.01"
                    class="border pl-1" />
                </div>
              </div>

              <label class="ml-4">- at</label>
              <div class="ml-7">
                <div class="my-1">
                  <label>X: </label>
                  <input
                    id="at_x"
                    type="number"
                    value="-1"
                    step="0.01"
                    class="border pl-1" />
                </div>
                <div class="my-1">
                  <label>Y: </label>
                  <input
                    id="at_y"
                    type="number"
                    value="0"
                    step="0.01"
                    class="border pl-1" />
                </div>
                <div class="my-1">
                  <label>Z: </label>
                  <input
                    id="at_z"
                    type="number"
                    value="0"
                    step="0.01"
                    class="border pl-1" />
                </div>
              </div>

              <label class="ml-4">- up</label>
              <div class="ml-7">
                <div class="my-1">
                  <label>X: </label>
                  <input
                    id="up_x"
                    type="number"
                    value="0"
                    step="1"
                    class="border pl-1" />
                </div>
                <div class="my-1">
                  <label>Y: </label>
                  <input
                    id="up_y"
                    type="number"
                    value="1"
                    step="1"
                    class="border pl-1" />
                </div>
                <div class="my-1">
                  <label>Z: </label>
                  <input
                    id="up_z"
                    type="number"
                    value="0"
                    step="1"
                    class="border pl-1" />
                </div>
              </div>
            </div>
          </div>

          <div class="animation">
            <p>animations:</p>
            <div class="ml-7">
              <button
                class="border px-1"
                onclick="rootManager.rootObject.children.robotArm.animator.start()">
                robotArm wave
              </button>
            </div>
          </div>
        </div>
      </div>

      <script id="main">
        const rootManager = new RootManager();
        rootManager.init();

        // 로봇 팔
        rootManager.rootObject.children["robotArm"] = new RobotArm(
          new Transform({
            position: vec3(0, -0.8, 0),
            rotation: vec3(0, 0, -30),
          })
        );

        // Primitive 테스트
        rootManager.rootObject.children["primitiveTestScene"] = new PrimitiveTestScene(
          new Transform()
        );

        // 낚시터 (x 양의 방향, y = 0.5)
        rootManager.rootObject.children["fishingGround"] = new FishingGround(
          new Transform()
        );

        // 바다 (x 음의 방향, y = -2.0)
        rootManager.rootObject.children["ocean"] = new Ocean(
          new Transform()
        );

        // 스카이박스 (배경 하늘)
        rootManager.rootObject.children["skyBox"] = new SkyBox(
          new Transform()
        );

        // 태양 (30, 30, 30 위치)
        rootManager.rootObject.children["sun"] = new Sun(
          new Transform({
            position: vec3(30, 30, 30)
          })
        );

        // 이미지 텍스처는 initTextures()에서 자동으로 로드됩니다

        rootManager.canvasManager.render();

        setLight = (event) => {
          // console.clear();

          rootManager.canvasManager.lightPosition = vec4(
            parseFloat(light_x.value),
            parseFloat(light_y.value),
            parseFloat(light_z.value)
          );
          rootManager.canvasManager.lightingSync();
        };

        setCanvas = (event) => {
          // console.clear();

          rootManager.cameraManager.eye = vec3(
            parseFloat(eye_x.value),
            parseFloat(eye_y.value),
            parseFloat(eye_z.value)
          );
          rootManager.cameraManager.at = vec3(
            parseFloat(at_x.value),
            parseFloat(at_y.value),
            parseFloat(at_z.value)
          );
          rootManager.cameraManager.up = vec3(
            parseFloat(up_x.value),
            parseFloat(up_y.value),
            parseFloat(up_z.value)
          );

          // 애니메이션이 실행 중이 아닐 때만 직접 렌더링
          if (!rootManager.animationManager.isPlaying) {
            rootManager.canvasManager.render();
          }
        };

        document
          .querySelectorAll("#light_x, #light_y, #light_z")
          .forEach((input) => {
            input.addEventListener("input", setLight);
          });
        document
          .querySelectorAll(
            "#eye_x, #eye_y, #eye_z, #at_x, #at_y, #at_z, #up_x, #up_y, #up_z"
          )
          .forEach((input) => {
            input.addEventListener("input", setCanvas);
          });

        resetCamera = () => {
          eye_x.value = 0;
          eye_y.value = 0;
          eye_z.value = 1;
          at_x.value = 0;
          at_y.value = 0;
          at_z.value = 0;
          up_x.value = 0;
          up_y.value = 1;
          up_z.value = 0;
        };

        frontCamera.addEventListener("click", (event) => {
          resetCamera();
          setCanvas();
        });
        sideCamera.addEventListener("click", (event) => {
          resetCamera();

          eye_x.value = 1;
          eye_y.value = 0;
          eye_z.value = 0;

          setCanvas();
        });
        topCamera.addEventListener("click", (event) => {
          resetCamera();

          eye_x.value = 0;
          eye_y.value = 1;
          eye_z.value = 0;

          up_x.value = 0;
          up_y.value = 0;
          up_z.value = -1;

          setCanvas();
        });
      </script>

      <script id="mouse">
        let prevMouseX = 0;
        let prevMouseY = 0;
        let currentButton = -1;
        /*
        currentButton 없이 그냥 if(e.button === 0), if(e.button === 2)로 비교하니,
        moveCameraByMouse에서 항상 e.button 값이 0으로 설정되는 문제가 있었음(타 event에서는 문제 없었음).
        따라서 현재 눌린 버튼을 저장하는 currentButton을 추가하고
        마우스 버튼을 누르고 뗄 때마다 값 업데이트하도록 설정하니 문제 해결됨.
        */

        function moveCameraByMouse(e) {
          const dx = e.clientX - prevMouseX;
          const dy = e.clientY - prevMouseY;

          // Debouncing, 마우스가 움직인 거리가 10 이하면 무시
          // 랜더링은 리소스를 많이 쓰므로
          if (dx * dx + dy * dy < 100) {
            return;
          }

          prevMouseX = e.clientX;
          prevMouseY = e.clientY;

          // 마우스가 움직일 때마다 호출
          if (currentButton === 0) {// left button: move camera (not rotating)
            rootManager.cameraManager.moveCamera(vec3(-dx / 500, dy / 500, 0));

          /*
          at을 고정한 채, camera rotation을 수행함. 
          마우스가 향하는 방향으로 카메라의 at을 증가시키며 rotate.
          다만 2D 회전의 한계로 마우스 이동만으로 실제 z축 회전을 구현하진 못했음.
          */
          } else if (currentButton === 2) { // right button: rotate camera
            const horizontalAngle = dx * 0.5/5;
            const verticalAngle = dy * 0.5/5;

            // horizontal rotation(Y axis)
            const rotationY = rotateY(horizontalAngle);
            let eye4 = vec4(rootManager.cameraManager.eye[0], rootManager.cameraManager.eye[1], rootManager.cameraManager.eye[2], 1.0);
            let up4 = vec4(rootManager.cameraManager.up[0], rootManager.cameraManager.up[1], rootManager.cameraManager.up[2], 0.0);
            
            eye4 = mult(rotationY, eye4);
            up4 = mult(rotationY, up4);
            
            rootManager.cameraManager.eye = vec3(eye4[0], eye4[1], eye4[2]);
            rootManager.cameraManager.up = vec3(up4[0], up4[1], up4[2]);

            // vertical rotation(X axis)
            const rotationX = rotateX(verticalAngle);
            eye4 = vec4(rootManager.cameraManager.eye[0], rootManager.cameraManager.eye[1], rootManager.cameraManager.eye[2], 1.0);
            up4 = vec4(rootManager.cameraManager.up[0], rootManager.cameraManager.up[1], rootManager.cameraManager.up[2], 0.0);
            
            eye4 = mult(rotationX, eye4);
            up4 = mult(rotationX, up4);
            
            rootManager.cameraManager.eye = vec3(eye4[0], eye4[1], eye4[2]);
            rootManager.cameraManager.up = vec3(up4[0], up4[1], up4[2]);
          }

          eye_x.value = rootManager.cameraManager.eye.X;
          eye_y.value = rootManager.cameraManager.eye.Y;
          eye_z.value = rootManager.cameraManager.eye.Z;

          at_x.value = rootManager.cameraManager.at.X;
          at_y.value = rootManager.cameraManager.at.Y;
          at_z.value = rootManager.cameraManager.at.Z;
          setCanvas();          
          // 애니메이션이 실행 중이 아닐 때만 직접 렌더링
          if (!rootManager.animationManager.isPlaying) {
            rootManager.canvasManager.render();
          }
        }

        // 왼쪽 버튼이든 오른쪽 버튼이든 로직은 같음.
        function handleMouseUp(e) {
          if (e.button === 0 || e.button === 2) {
            document.removeEventListener("mousemove", moveCameraByMouse);
            document.removeEventListener("mouseup", handleMouseUp);
            currentButton = -1;
          }
        }

        function handleMouseDown(e) {
          prevMouseX = e.clientX;
          prevMouseY = e.clientY;

          if (e.button === 0 || e.button === 2) {
            currentButton = e.button;
            document.addEventListener("mousemove", moveCameraByMouse);
            document.addEventListener("mouseup", handleMouseUp);
          }
        }

        function handleWheel(e) {
          const delta = e.deltaY * 0.001*2;
          
          // move camera in the current direction(only distance)
          const viewDirection = subtract(rootManager.cameraManager.at, rootManager.cameraManager.eye);
          let distance = length(viewDirection);
          normalize(viewDirection);
          
          // adjust distance(limit the minimum/maximum distance)
          distance = Math.max(0.1, Math.min(1000.0, distance + delta));
          rootManager.cameraManager.eye = subtract(rootManager.cameraManager.at, scale(distance, viewDirection));

          // control panel과 동기화
          eye_x.value = rootManager.cameraManager.eye.X;
          eye_y.value = rootManager.cameraManager.eye.Y;
          eye_z.value = rootManager.cameraManager.eye.Z;
          setCanvas();
          // 애니메이션이 실행 중이 아닐 때만 직접 렌더링
          if (!rootManager.animationManager.isPlaying) {
            rootManager.canvasManager.render();
          }
        }

        // 우클릭 창 나오는 것 방지.
        // 초기에 mousedown 리스너뿐만 아니라 wheel 리스너도 추가해 줌
        document.addEventListener("contextmenu", function(e) {
          e.preventDefault();
        });
        document.addEventListener("mousedown", handleMouseDown);
        document.addEventListener("wheel", handleWheel);
      </script>
    </div>
  </body>
</html>
